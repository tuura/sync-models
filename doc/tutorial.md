### Tutorial

This tutorial will walk you through generating a sync model and examining its
content. As an example we will use the `d-element` async circuit in the tool's
`examples` directory.

#### Input Circuit

The content of the input circuit (`examples/d-element/circuit.v`) are shown
below:

```verilog
// Verilog netlist generated by Workcraft 3 -- https://workcraft.org/
module Untitled (ao, ri, ai, ro);
    input ao, ri;
    output ai, ro;

    NOR2 _U0 (.ON(ai), .A(ao), .B(_U2_QN));
    AND2 _U1 (.O(ro), .A(ri), .B(_U2_QN));
    NC2 _U2 (.QN(_U2_QN), .A(ao), .B(ri));

    // signal values at the initial state:
    // !ai !ro _U2_QN !ao !ri
endmodule
```

This circuit was generated from a formal specification by
[Workcraft](https://workcraft.org/).

#### Running the Tool

A synchronous model of the above circuit can be generated by running:

```
./generator.py examples/d-element/circuit.v > model.v
```

from the tool's root directory.

#### Output Circuit

The content of the generated `model.v` are shown below. The file contains two
modules: the sync model `circuit_inner` and a thin wrapper `circuit` that
provides the same interface as the input circuit.

From a quick look at `circuit`, the main components of the model are:

- the same logic gates in the input circuit (`_U0`, `_U1` and `_U2`)
- additional flip-flops to capture wire states (e.g. `ao_ff`)
- an unbound register `fire` that determines transition ordering

```verilog
// vi: set ft=verilog :

module circuit (
        input reset,
        input clk,
        input ao,
        input ri,
        output ai,
        output ro
    );

    // This is a thin wrapper to provide the same interface as the original
    // circuit.

    circuit_inner circuit1 (
        .reset(reset),
        .clk(clk),
        .ao_precap(ao),
        .ri_precap(ri),
        .ai(ai),
        .ro(ro)
    );

endmodule

module circuit_inner (
        input reset,
        input clk,
        input ao_precap,
        input ri_precap,
        output ai,
        output ro
    );

    reg [2:0] fire; // unbound register

    // input signal 'ao' (initial value = 0)

    DFF ao_ff (
        .CK(clk),
        .ST(1'b0),
        .RS(reset),
        .D(ao_precap),
        .Q(ao),
        .ENA(fire == 0)
    );

    // input signal 'ri' (initial value = 0)

    DFF ri_ff (
        .CK(clk),
        .ST(1'b0),
        .RS(reset),
        .D(ri_precap),
        .Q(ri),
        .ENA(fire == 1)
    );

    // internal signal '_U2_QN' (initial value = 1)

    NC2 _U2 (
        .CK(clk),
        .RS(1'b0),
        .ST(reset),
        .PRECAP(_U2_QN_precap),
        .A(ao),
        .B(ri),
        .QN(_U2_QN),
        .ENA(fire == 2)
    );

    // output signal 'ro' (initial value = 0)

    AND2 _U1 (.A(ri), .B(_U2_QN), .O(ro_precap));

    DFF _U1_ff (
        .CK(clk),
        .ST(1'b0),
        .RS(reset),
        .D(ro_precap),
        .Q(ro),
        .ENA(fire == 4)
    );

    // output signal 'ai' (initial value = 0)

    NOR2 _U0 (.A(ao), .ON(ai_precap), .B(_U2_QN));

    DFF _U0_ff (
        .CK(clk),
        .ST(1'b0),
        .RS(reset),
        .D(ai_precap),
        .Q(ai),
        .ENA(fire == 3)
    );

    // Stateless modules

endmodule
```
